/* * Copyright (c) 2001-2003 Swedish Institute of Computer Science. * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification,  * are permitted provided that the following conditions are met: * * 1. Redistributions of source code must retain the above copyright notice, *    this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, *    this list of conditions and the following disclaimer in the documentation *    and/or other materials provided with the distribution. * 3. The name of the author may not be used to endorse or promote products *    derived from this software without specific prior written permission.  * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE. * * This file is part of the lwIP TCP/IP stack. *  * Author: Adam Dunkels <adam@sics.se> * */#include "lwip/opt.h"#include "lwip/def.h"#include "fs.h"#include "fsdata.h"#include <stdio.h>#include <Errors.h>#include <Files.h>#include <string.h>#define FS_ROOT NULL #define FS_FILE_BUFF_SIZE 4096#if !HTTPD_PRECALCULATED_CHECKSUMstatic char *fileBuff;static unsigned int fileBuffSize;#endif /* HTTPD_PRECALCULATED_CHECKSUM *//*-----------------------------------------------------------------------------------*/voidfs_close_custom(struct fs_file *file){	OSErr error;#if HTTPD_PRECALCULATED_CHECKSUM && LWIP_HTTPD_DYNAMIC_FILE_READ	/* Slyly store the file reference in the checksum */ 	long refNum = (long)file->chksum_count;		error = FSClose(refNum);	LWIP_ERROR("Unable to close File", (error == noErr ), return;);	LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("fs_close_custom()\n"));#endif}/*-----------------------------------------------------------------------------------*/intfs_path_to_mac(char *path_string){	char *curr_loc = path_string;		/* HFS Only */	curr_loc = strchr(curr_loc, '/');	while (curr_loc != NULL)	{		*curr_loc = ':';		curr_loc = strchr(curr_loc, '/');	}	}/*-----------------------------------------------------------------------------------*/#if HTTPD_PRECALCULATED_CHECKSUM && LWIP_HTTPD_DYNAMIC_FILE_READintfs_open_custom(struct fs_file *file, const char *name){	OSErr error = fsDSIntErr;		long readCount;		Str255 pName;	short vRefNum = 0;	short refNum; 		char firstChar;	/*	Only open files with an extension for 'security'.*/	if ( strchr(name, '.') == NULL ) 		return 0;	/* Convert file name to pascal string. */	strncpy((char *)pName, name, 255);	//fs_path_to_mac((char *)pName);	pName[0] = (char)strlen(name)-1; /* Overwrite the first character which is a ':' or '/' */		/* Open the file. */	error = FSOpen(pName, vRefNum, &refNum);	if (error != noErr) {		LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("FSopen() error:%d\n", error));		return 0;	}		/* Figure out how long the file is. */	error = GetEOF(refNum, &readCount);	file->len = readCount;	file->index = 0;	file->pextension = NULL;	/* Slyly store the file reference in the checksum. */ 	file->chksum_count = (u16_t)refNum;	//file->http_header_included = false;	/*	Check if the first letter of the file is 'H' which indicates that the HTTP header is included. 		This doesn't work because if LWIP_HTTPD_DYNAMIC_FILE_READ is enabled, 		the file is not read until after http_init_file which is where the header is separated. */	readCount = 1;	error = FSRead(refNum, &readCount, &firstChar);	LWIP_ERROR(("Unable to read file."), (error == noErr), fs_close_custom(file); return 0;);	file->http_header_included = (firstChar == 'H');		/* Reset to start of file. */	error = SetFPos(refNum, fsFromStart, 0);		return 1;}#else /*HTTPD_PRECALCULATED_CHECKSUM*//*-----------------------------------------------------------------------------------*/intfs_open_custom(struct fs_file *file, const char *name){	OSErr error = fsDSIntErr;		long readCount;		Str255 pName;	short vRefNum = 0;	short refNum; 		/*	Only open files with an extension for 'security'.*/	if ( strchr(name, '.') == NULL ) 		return 0;	/* Allocate a file buffer, if necessary.*/	if (fileBuff == NULL)	{		for (fileBuffSize = FS_FILE_BUFF_SIZE; fileBuff == NULL && fileBuffSize >= 512; fileBuffSize /= 2)		{			fileBuff = (char *)malloc(fileBuffSize);		}			LWIP_ERROR(("Unable to allocate memory for file buffer."), (fileBuff != NULL), return 0;);	}	file->data = fileBuff;	/* Convert file name to pascal string. */	strncpy((char *)pName, name, 255);	//fs_path_to_mac((char *)pName);	pName[0] = (char)strlen(name)-1; /* Overwrite the first character which is a ':' or '/' */		/* Open the file. */	error = FSOpen(pName, vRefNum, &refNum);	if (error != noErr) {		LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("FSopen() error:%d\n", error));		return 0;	}		/* Figure out how long the file is. */	error = GetEOF(refNum, &readCount);	LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("GetEOF readCount:%d\n", readCount));	LWIP_ERROR(("File is too big to load."), (file->len < fileBuffSize), readCount = fileBuffSize;);	/* Read the file. */			error = FSRead(refNum, &readCount, (char *)file->data);	LWIP_ERROR(("FSRead() error"), (error == noErr), return 1;);	LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("FSRead readCount:%d\n", readCount));	file->len = readCount;	file->index = file->len;	file->pextension = NULL;	file->http_header_included = true;	if (file->data[0] != 'H')	{		LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_LEVEL_WARNING, ("Warning: Header Not Included in File: %P\n", name));		file->http_header_included = false;	}		/* Close the file. */	error = FSClose(refNum);	LWIP_ERROR("Unable to close File", (error == noErr ), return;);		return 1;}#endif /*HTTPD_PRECALCULATED_CHECKSUM*/#if HTTPD_PRECALCULATED_CHECKSUM && LWIP_HTTPD_DYNAMIC_FILE_READ/* Set these as 0, so that the methods in fs.c are eliminated, and we can use our own. */#define LWIP_HTTPD_DYNAMIC_FILE_READ	0#define LWIP_HTTPD_FS_ASYNC_READ		0intfs_read(struct fs_file *file, char *buffer, int count){	OSErr error = fsDSIntErr;	long readCount =  (long)count;	short refNum = (short)file->chksum_count;		if (file->index >= file->len)	{		return FS_READ_EOF;	}	else if ((file->index + count) > file->len)	{		readCount = (long)(file->len - file->index);	}		error = FSRead(refNum, &readCount, buffer);	LWIP_ERROR(("FSRead() error\n"), (error == noErr), LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_LEVEL_WARNING, ("FSRead() error:%d\n", error)); return FS_READ_EOF;);	file->index += readCount;	return((int)readCount);}#endif /*HTTPD_PRECALCULATED_CHECKSUM*/